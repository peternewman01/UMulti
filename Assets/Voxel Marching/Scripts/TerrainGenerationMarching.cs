using JetBrains.Annotations;
using System.Collections.Generic;
using System.ComponentModel;
using Unity.IO.LowLevel.Unsafe;
using Unity.Netcode;
using Unity.VisualScripting.FullSerializer;
using UnityEditor.SettingsManagement;
using UnityEngine;

[RequireComponent(typeof(MarchingAlgorithm))]
public class TerrainGenerationMarching : NetworkBehaviour
{
    protected MarchingAlgorithm algorithm;

    private void Awake()
    {
        algorithm = GetComponent<MarchingAlgorithm>();
    }
    public float[,,] GenerateTerrainData(int cubeSize, ITerrainGeneration islandGeneration)
    {
        Vector2Int chunk = algorithm.GetChunk();
        int subChunk = algorithm.GetSubChunk();
        int voxelArea = algorithm.GetVoxelArea();
        int yOffset = subChunk * voxelArea;
        float[,,] terrainData = { };
        for (int x = 0; x < voxelArea + 1; x++)
        {
            for (int z = 0; z < voxelArea + 1; z++)
            {
                float[] airGaps = islandGeneration.CustomNoise(ChunkMananger.Instance.ChunkToWorld(chunk) + new Vector3(x, 0, z), algorithm);
                ProcessTerrainData(x, z, airGaps, terrainData, subChunk, voxelArea, yOffset);
            }
        }
        

        return terrainData;
    }
    /// <summary>
    /// Will use the dictionary generated by ProcessTerrainData to update the array of terrain data
    /// will assume air below first value
    /// </summary>
    /// <param name="terrainData"></param>
    /// <param name=""></param>

    protected virtual void ProcessTerrainData(int x, int z, float[] yData, float[,,] terrainData, int subChunk, int voxelArea, int yOffset)
    {
        SortedDictionary<int, float> pointData = new();
        for (int airIndex = 0; airIndex < yData.Length - 1; airIndex += 2)
        {
            float minHeight = yData[airIndex];
            float maxHeight = yData[airIndex + 1];

            for (int y = 0; y < voxelArea + 1; y++)
            {

                int yValue = y + yOffset;
                float point = algorithm.GetPointValue(yValue, minHeight, maxHeight);

                algorithm.SetHasData(point > 0f);
                terrainData[x, y, z] = point;

                if (airIndex + 2 < yData.Length && yValue > maxHeight + 0.5f)
                {
                    airIndex += 2;
                    maxHeight = yData[airIndex + 1];
                    minHeight = yData[airIndex];
                    y = (int)minHeight;
                }
            }
        }

        return;
    }

    public MarchingAlgorithm GetAlgorithm() => algorithm;
}
